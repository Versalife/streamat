# Worklog - 09-01-2025

## Project Enhancement: On-the-fly Data Conversion and Web URI Support

### 1. Overview

This document outlines the design and implementation plan for enhancing the `streammat` project. The primary goal is to streamline the data ingestion process by enabling the server to perform on-the-fly conversions of data from various formats and locations (local and remote). This will significantly improve the user experience, as users will no longer need to manually convert their data before loading it into the server.

### 2. Core Requirements

- **On-the-fly Conversion:** The server will automatically convert non-TileDB data into the TileDB format.
- **Web URI Support:** The server will accept web URIs (HTTP/HTTPS) and download the data for conversion.
- **Temporary File Management:** Downloaded files will be stored temporarily and cleaned up after conversion.
- **URI Type Detection:** The server will differentiate between local file paths and remote URIs.
- **Format Detection:** The server will attempt to determine the file type before downloading to avoid unnecessary bandwidth usage.
- **Performance:** The entire process will be designed for high performance and concurrency.
- **Backwards Compatibility:** The existing `streammat-convert` CLI tool will be preserved.
- **Scalability:** The architecture will be designed to handle a massive number of requests, laying the groundwork for a "billion-request-per-second" system.

### 3. High-Level Design

The enhancement will be centered around a new `DataManager` module. This module will be responsible for:

1.  **URI Analysis:** Receiving a URI and determining if it's a local path or a remote URL.
2.  **Content-Type Probing (for remote URIs):** Making a lightweight `HEAD` request to inspect the `Content-Type` and `Content-Disposition` headers to infer the file format before committing to a full download.
3.  **Data Fetching:**
    -   If it's a local file, ensuring it exists.
    -   If it's a remote URL, downloading the file into a managed temporary directory.
4.  **Format Identification:** Determining the matrix format (Matrix Market, Harwell-Boeing, etc.) from the file extension or content.
5.  **Conversion:** Programmatically invoking the core conversion logic (currently in `conversion.py`) to transform the input file into a TileDB array in a designated "cache" directory.
6.  **Cleanup:** Deleting the downloaded source file after a successful conversion. The TileDB array will be preserved.
7.  **Loading:** Returning the path to the newly created TileDB array so it can be loaded into the `StreamMatrix` object.

### 4. Detailed Implementation Plan

#### Phase 1: Refactor Conversion Logic

- **Goal:** Decouple the conversion logic from the `Typer` CLI in `conversion.py`.
- **Action:**
    -   Create a new function, e.g., `convert_to_tiledb(input_path: str, output_uri: str, dtype: np.dtype, overwrite: bool)`.
    -   This function will contain the core logic that reads the input file and writes to the TileDB array.
    -   The existing `streammat-convert` CLI function will be refactored to simply call this new core function.
- **Benefit:** This makes the conversion logic reusable and callable from other parts of the application, like the server.

#### Phase 2: Create the `DataManager`

- **Goal:** Implement the central module for handling data ingestion.
- **File:** `streammat/data_manager.py`
- **Class:** `DataManager`
- **Methods:**
    -   `__init__(self, temp_dir: str, cache_dir: str)`: Initializes the manager with paths for temporary downloads and the TileDB cache.
    -   `async def provision_matrix(self, uri: str, matrix_name: str) -> str`: The main entry point. It will take a user-provided URI and a desired name for the matrix.
        -   It will orchestrate the steps: analyze URI, fetch, convert, and clean up.
        -   It will return the URI of the final TileDB array.
    -   `_is_remote(self, uri: str) -> bool`: A helper to check if a URI is a URL.
    -   `_get_remote_file_format(self, uri: str) -> Optional[str]`: Uses `httpx.head` to check headers.
    -   `_download_file(self, uri: str) -> str`: Downloads the file to the `temp_dir`.
    -   `_get_local_file_format(self, path: str) -> str`: Determines format from file extension.
    -   `_cleanup_temp_file(self, path: str)`: Deletes a file from `temp_dir`.

#### Phase 3: Integrate `DataManager` into the Server

- **Goal:** Modify the server to use the new on-the-fly conversion feature.
- **File:** `server.py`
- **Action:**
    -   Modify the `PUT /api/v1/matrix/{matrix_name}` endpoint.
    -   The request body will be updated to accept a generic `uri` field.
    -   The endpoint will first check if the provided URI points to an existing TileDB array. If so, it will load it directly (backwards compatibility).
    -   If not, it will instantiate the `DataManager` and call `provision_matrix`.
    -   The resulting TileDB array path from the `DataManager` will then be loaded into the `StreamMatrix`.
- **Configuration:**
    -   Add `STREAMMAT_TEMP_DIR` and `STREAMMAT_CACHE_DIR` to the server's configuration (`config.py`) to make these paths configurable.

#### Phase 4: World-Class Infrastructure Enhancements

To build towards a "billion-request-per-second" system, we need to think about scalability, concurrency, and robustness from the start.

- **Asynchronous Everything:** All I/O operations (downloading, file reading, TileDB writing) will be fully asynchronous to the greatest extent possible. We will leverage `aiohttp` or `httpx` for downloads and `asyncio`'s thread pool executor for blocking file I/O if necessary.
- **Request Deduplication:** If two users request the same URI simultaneously, we should not download and convert it twice. We will implement a locking mechanism (e.g., an `asyncio.Lock` keyed by the URI hash) within the `DataManager` to ensure that a given resource is only processed once.
- **Caching Strategy:** The `STREAMMAT_CACHE_DIR` is our first level of caching. We will implement a Least Recently Used (LRU) policy for the TileDB arrays stored in the cache to manage disk space. A background task could periodically clean up old, unused arrays.
- **Distributed Locking:** For a multi-node, horizontally scaled deployment, a local `asyncio.Lock` is insufficient. We will design the `DataManager` with a pluggable locking backend. The default will be a local lock, but it could be swapped for a distributed lock using Redis or ZooKeeper. This ensures that even across multiple server instances, a URI is only processed once.
- **Content Delivery Network (CDN) and Edge Computing:** For truly massive scale, the conversion logic itself could be deployed as a serverless function (e.g., AWS Lambda, Cloudflare Workers) at the edge. The `streammat` server would then just orchestrate these edge functions. This is a future consideration but will be kept in mind during the design.

### 5. Testing Strategy

- **Unit Tests:**
    -   Test the `DataManager`'s URI detection (`_is_remote`).
    -   Test the format detection logic.
    -   Mock the download and conversion process to test the orchestration logic of `provision_matrix`.
- **Integration Tests:**
    -   Create a test that provides a URL to a real (but small) `.mtx` file on a local test server.
    -   Verify that the server downloads, converts, and can successfully load and use the matrix.
    -   Verify that the temporary file is deleted and the TileDB array is created in the cache.
- **End-to-End Tests:**
    -   Expand the `example.py` script or create a new one to demonstrate the new workflow with a remote URI.

This plan provides a clear path forward for turning `streammat` into a more powerful and user-friendly platform, while also laying the architectural foundation for future scalability.
